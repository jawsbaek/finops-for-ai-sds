# Story 1.12: ì„±ëŠ¥ ìµœì í™” - ì¿¼ë¦¬ ìµœì í™” ë° ì¸ë±ìŠ¤ ì¶”ê°€

**Status:** ğŸ“‹ TODO

**Priority:** ğŸŸ¡ MEDIUM

---

## User Story

**As a** ì‹œìŠ¤í…œ ì‚¬ìš©ì,
**I want** í”„ë¡œì íŠ¸ ìƒì„¸ í˜ì´ì§€ì™€ ë©¤ë²„ ê´€ë¦¬ ê¸°ëŠ¥ì´ ë¹ ë¥´ê²Œ ë¡œë“œë˜ì–´,
**So that** ëŒ€ê¸° ì‹œê°„ ì—†ì´ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ì—…í•  ìˆ˜ ìˆë‹¤.

---

## Context

**Code Review ë°œê²¬ ì‚¬í•­ (Story 1.10):**

### Issue #1: N+1 Query Problem (HIGH)
**ë¬¸ì œ:**
```typescript
// src/server/api/routers/team.ts - getMembers
const membership = await db.teamMember.findUnique({
  where: { teamId_userId: { teamId: input.teamId, userId } }
});  // Query 1: Permission check

if (!membership) throw new TRPCError({ code: "FORBIDDEN" });

const members = await db.teamMember.findMany({
  where: { teamId: input.teamId },
  include: { user: { select: { id: true, name: true, email: true } } },
});  // Query 2: Actual data fetch
```

**ë¬¸ì œì :**
- ê°™ì€ í…Œì´ë¸”ì„ 2ë²ˆ ì¡°íšŒ (permission check + data fetch)
- ë°ì´í„°ê°€ ì¤‘ë³µìœ¼ë¡œ ì¡°íšŒë¨
- ë¶ˆí•„ìš”í•œ DB round-trip

**í•´ê²° ë°©ë²•:**
```typescript
const members = await db.teamMember.findMany({
  where: { teamId: input.teamId },
  include: { user: { select: { id: true, name: true, email: true } } },
});

const currentUserMembership = members.find(m => m.userId === userId);
if (!currentUserMembership) throw new TRPCError({ code: "FORBIDDEN" });

return members;
```

### Issue #2: Query Waterfall (MEDIUM)
**ë¬¸ì œ:**
```typescript
// src/app/(dashboard)/projects/[id]/page.tsx
const { data: project } = api.project.getById.useQuery({ id: projectId });
const { data: projectMembers } = api.project.getMembers.useQuery({ projectId });
const { data: teamMembers } = api.team.getMembers.useQuery(
  { teamId: project?.team.id ?? "" },
  { enabled: !!project?.team.id }  // âš ï¸ Waits for project query
);
```

**ë¬¸ì œì :**
- `teamMembers` ì¿¼ë¦¬ê°€ `project` ì¿¼ë¦¬ ì™„ë£Œê¹Œì§€ ëŒ€ê¸°
- ìˆœì°¨ì  ë¡œë”©ìœ¼ë¡œ ì¸í•œ ì§€ì—° (waterfall)
- ì´ ë¡œë”© ì‹œê°„ = Query1 + Query2 + Query3

**í•´ê²° ë°©ë²•:**
- `projectId`ì—ì„œ ì§ì ‘ `teamId`ë¥¼ ì¡°íšŒí•˜ëŠ” ìµœì í™”ëœ ì¿¼ë¦¬ ì‚¬ìš©
- ë˜ëŠ” ì„œë²„ ì‚¬ì´ë“œì—ì„œ ëª¨ë“  ë°ì´í„°ë¥¼ í•œ ë²ˆì— fetch

### Issue #3: Missing Database Indexes (MEDIUM)
**ë¬¸ì œ:**
```prisma
model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  // âš ï¸ No index on userId
  // âš ï¸ No compound index on (projectId, userId)
}

model ApiKey {
  id           String   @id @default(cuid())
  projectId    String
  isActive     Boolean  @default(true)
  // âš ï¸ No compound index on (projectId, isActive)
}

model AuditLog {
  id           String   @id @default(cuid())
  userId       String
  actionType   String
  resourceType String
  resourceId   String
  createdAt    DateTime @default(now())
  // âš ï¸ No indexes for common queries
}
```

**ë¬¸ì œì :**
- `WHERE userId = ?` ì¿¼ë¦¬ê°€ full table scan
- API í‚¤ ëª©ë¡ ì¡°íšŒ ì‹œ ë¹„íš¨ìœ¨ì  í•„í„°ë§
- Audit log ì¡°íšŒ ì‹œ ëŠë¦° ì„±ëŠ¥

**í•´ê²° ë°©ë²•:**
- ìì£¼ ì¡°íšŒí•˜ëŠ” ì»¬ëŸ¼ì— ì¸ë±ìŠ¤ ì¶”ê°€
- ë³µí•© ì¡°ê±´ ì¿¼ë¦¬ì— compound index ì¶”ê°€

### Issue #4: Lack of Query Result Caching (LOW)
**ë¬¸ì œ:**
- React Queryì˜ stale timeì´ ë„ˆë¬´ ì§§ìŒ (ê¸°ë³¸ê°’ 0)
- ê°™ì€ ë°ì´í„°ë¥¼ ë°˜ë³µ fetch

**í•´ê²° ë°©ë²•:**
- ìì£¼ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ë°ì´í„°ì— staleTime ì„¤ì •
- í”„ë¡œì íŠ¸ ë©¤ë²„, íŒ€ ë©¤ë²„: 5ë¶„
- API í‚¤ ëª©ë¡: 1ë¶„

---

## Acceptance Criteria

### 1. N+1 Query ì œê±°
- [ ] `team.getMembers` ì¿¼ë¦¬ë¥¼ ë‹¨ì¼ ì¿¼ë¦¬ë¡œ ìµœì í™”
- [ ] `project.getMembers` ì¿¼ë¦¬ ìµœì í™” (permission check í†µí•©)
- [ ] Prisma query ë¡œê·¸ë¡œ ì‹¤í–‰ë˜ëŠ” SQL ì¿¼ë¦¬ ìˆ˜ í™•ì¸
- [ ] Before: 2 queries â†’ After: 1 query per request

### 2. Query Waterfall í•´ê²°
- [ ] í”„ë¡œì íŠ¸ ìƒì„¸ í˜ì´ì§€ ì´ˆê¸° ë¡œë”© ìµœì í™”:
  - Option A: Server Componentì—ì„œ ëª¨ë“  ë°ì´í„° prefetch
  - Option B: `projectId`ì—ì„œ ì§ì ‘ `teamId` ì¡°íšŒí•˜ëŠ” ê²½ëŸ‰ endpoint ì¶”ê°€
- [ ] ë³‘ë ¬ ì¿¼ë¦¬ ì‹¤í–‰ìœ¼ë¡œ ë¡œë”© ì‹œê°„ ë‹¨ì¶•
- [ ] Before: ~600ms â†’ After: ~200ms (3ê°œ ì¿¼ë¦¬ ë³‘ë ¬)

### 3. Database Index ì¶”ê°€
- [ ] Prisma schema ì—…ë°ì´íŠ¸:
```prisma
model ProjectMember {
  @@index([userId])
  @@index([projectId, userId])
}

model ApiKey {
  @@index([projectId, isActive])
}

model AuditLog {
  @@index([userId])
  @@index([resourceType, resourceId])
  @@index([actionType])
  @@index([createdAt])
}
```
- [ ] Migration ìƒì„± ë° ì‹¤í–‰
- [ ] Explain analyzeë¡œ index ì‚¬ìš© í™•ì¸
- [ ] Before: Full table scan â†’ After: Index scan

### 4. Query Result Caching ìµœì í™”
- [ ] tRPC clientì— staleTime ì„¤ì •:
```typescript
export const api = createTRPCReact<AppRouter>({
  overrides: {
    queries: {
      staleTime: 60 * 1000, // 1 minute default
    },
  },
});
```
- [ ] ê°œë³„ ì¿¼ë¦¬ë³„ ì„¸ë¶€ ì¡°ì •:
  - `project.getMembers`: 5ë¶„
  - `team.getMembers`: 5ë¶„
  - `project.getApiKeys`: 1ë¶„
  - `project.getById`: 30ì´ˆ
- [ ] Cache invalidation ë¡œì§ ê²€ì¦ (mutation í›„)

### 5. Performance Monitoring
- [ ] Prisma query ë¡œê¹… í™œì„±í™” (dev í™˜ê²½)
- [ ] ì£¼ìš” í˜ì´ì§€ ë¡œë”© ì‹œê°„ ì¸¡ì • (before/after)
- [ ] Database connection pool ìµœì í™” (pool size: 10 â†’ 20)

---

## Prerequisites

- Story 1.10 (í”„ë¡œì íŠ¸ ë©¤ë²„ ë° API í‚¤ ê´€ë¦¬ UI)

---

## Technical Implementation

### 1. N+1 Query Fix

**Before:**
```typescript
// src/server/api/routers/team.ts
getMembers: protectedProcedure
  .input(z.object({ teamId: z.string() }))
  .query(async ({ ctx, input }) => {
    const userId = ctx.session.user.id;

    // Query 1: Permission check
    const membership = await db.teamMember.findUnique({
      where: { teamId_userId: { teamId: input.teamId, userId } }
    });

    if (!membership) {
      throw new TRPCError({ code: "FORBIDDEN", message: "Not a team member" });
    }

    // Query 2: Fetch all members
    return await db.teamMember.findMany({
      where: { teamId: input.teamId },
      include: { user: { select: { id: true, name: true, email: true } } },
    });
  }),
```

**After:**
```typescript
// src/server/api/routers/team.ts
getMembers: protectedProcedure
  .input(z.object({ teamId: z.string() }))
  .query(async ({ ctx, input }) => {
    const userId = ctx.session.user.id;

    // Single query: Fetch all members
    const members = await db.teamMember.findMany({
      where: { teamId: input.teamId },
      include: { user: { select: { id: true, name: true, email: true } } },
      orderBy: [{ role: "asc" }, { createdAt: "asc" }],
    });

    // In-memory permission check
    const currentUserMembership = members.find(m => m.userId === userId);
    if (!currentUserMembership) {
      throw new TRPCError({
        code: "FORBIDDEN",
        message: "ì´ íŒ€ì— ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.",
      });
    }

    return members;
  }),
```

**Performance Gain:** 2 queries â†’ 1 query (~50% reduction)

### 2. Query Waterfall Fix

**Option A: Server Component Prefetch (Recommended)**
```typescript
// src/app/(dashboard)/projects/[id]/page.tsx
import { createServerSideHelpers } from "@trpc/react-query/server";
import { appRouter } from "@/server/api/root";

export async function generateMetadata({ params }: { params: { id: string } }) {
  // ... existing code
}

export default async function ProjectDetailPage({ params }: { params: { id: string } }) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: await createContext(),
  });

  const projectId = params.id;

  // Prefetch all data in parallel (server-side)
  await Promise.all([
    helpers.project.getById.prefetch({ id: projectId }),
    helpers.project.getMembers.prefetch({ projectId }),
    helpers.project.getApiKeys.prefetch({ projectId }),
  ]);

  // Fetch project to get teamId, then prefetch team members
  const project = await helpers.project.getById.fetch({ id: projectId });
  if (project) {
    await helpers.team.getMembers.prefetch({ teamId: project.team.id });
  }

  return <ProjectDetailClientPage projectId={projectId} />;
}
```

**Option B: Lightweight Endpoint**
```typescript
// src/server/api/routers/project.ts
getProjectWithTeamId: protectedProcedure
  .input(z.object({ projectId: z.string() }))
  .query(async ({ ctx, input }) => {
    const project = await db.project.findUnique({
      where: { id: input.projectId },
      select: {
        id: true,
        name: true,
        teamId: true,  // Only fetch teamId
      },
    });

    if (!project) {
      throw new TRPCError({ code: "NOT_FOUND" });
    }

    return project;
  }),
```

**Performance Gain:** 600ms â†’ 200ms (3x faster)

### 3. Database Indexes

```prisma
// prisma/schema.prisma

model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  createdAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([userId])              // âœ… NEW: For user's projects lookup
  @@index([projectId, userId])   // âœ… NEW: Compound index for joins
}

model ApiKey {
  id           String    @id @default(cuid())
  provider     String
  encryptedKey String
  last4        String    @db.VarChar(4)
  isActive     Boolean   @default(true)
  projectId    String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([projectId, isActive])  // âœ… NEW: For active key filtering
  @@index([last4])
}

model AuditLog {
  id           String   @id @default(cuid())
  userId       String
  actionType   String
  resourceType String
  resourceId   String
  metadata     Json?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])                         // âœ… NEW: For user activity log
  @@index([resourceType, resourceId])       // âœ… NEW: For resource audit trail
  @@index([actionType])                     // âœ… NEW: For action type filtering
  @@index([createdAt(sort: Desc)])          // âœ… NEW: For time-based queries
  @@index([userId, createdAt(sort: Desc)])  // âœ… NEW: User's recent activity
}
```

**Create migration:**
```bash
npx prisma migrate dev --name add-performance-indexes
```

**Verify index usage:**
```sql
EXPLAIN ANALYZE
SELECT * FROM "ProjectMember"
WHERE "projectId" = 'xxx' AND "userId" = 'yyy';
-- Should show "Index Scan" instead of "Seq Scan"
```

### 4. Query Caching Configuration

```typescript
// src/utils/api.tsx
import { createTRPCReact } from "@trpc/react-query";
import type { AppRouter } from "@/server/api/root";

export const api = createTRPCReact<AppRouter>();

// Query client configuration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,  // 1 minute default
      cacheTime: 5 * 60 * 1000,  // 5 minutes
      refetchOnWindowFocus: false,  // Reduce unnecessary refetches
      retry: 1,  // Reduce retry attempts
    },
  },
});
```

**Per-query configuration:**
```typescript
// src/app/(dashboard)/projects/[id]/page.tsx
const { data: projectMembers } = api.project.getMembers.useQuery(
  { projectId },
  {
    staleTime: 5 * 60 * 1000,  // 5 minutes (rarely changes)
  }
);

const { data: apiKeys } = api.project.getApiKeys.useQuery(
  { projectId },
  {
    staleTime: 1 * 60 * 1000,  // 1 minute (may change more frequently)
  }
);
```

### 5. Database Connection Pool Optimization

```typescript
// src/server/db.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const db =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
  });

// Connection pool settings (via DATABASE_URL)
// ?connection_limit=20&pool_timeout=10
```

**Update DATABASE_URL:**
```env
# .env
DATABASE_URL="postgresql://user:pass@localhost:5432/db?connection_limit=20&pool_timeout=10"
```

---

## Performance Benchmarks

### Before Optimization
| Metric | Value |
|--------|-------|
| Project detail page load | ~600ms |
| Team members query | 2 DB queries |
| API keys query (100 keys) | ~150ms (no index) |
| Audit log query (1000 logs) | ~500ms (full scan) |

### After Optimization
| Metric | Value | Improvement |
|--------|-------|-------------|
| Project detail page load | ~200ms | 3x faster |
| Team members query | 1 DB query | 50% reduction |
| API keys query (100 keys) | ~20ms | 7.5x faster |
| Audit log query (1000 logs) | ~50ms | 10x faster |

---

## Testing Checklist

### Performance Tests
- [ ] Measure page load time before/after (Chrome DevTools)
- [ ] Prisma query logging: Verify single query for `getMembers`
- [ ] Database `EXPLAIN ANALYZE`: Verify index usage
- [ ] Load test: 100 concurrent users (k6 or Artillery)

### Functional Tests
- [ ] All existing features still work after optimization
- [ ] Cache invalidation works correctly
- [ ] No stale data issues

---

## Monitoring

```typescript
// Add to Prisma client (dev only)
const prisma = new PrismaClient({
  log: [
    { emit: 'event', level: 'query' },
    { emit: 'stdout', level: 'error' },
    { emit: 'stdout', level: 'warn' },
  ],
});

prisma.$on('query', (e) => {
  console.log('Query: ' + e.query);
  console.log('Duration: ' + e.duration + 'ms');
});
```

---

## Success Metrics

- [ ] Page load time reduced by > 50% (600ms â†’ 200ms)
- [ ] Database query count reduced by > 30%
- [ ] All queries use indexes (verified via EXPLAIN)
- [ ] Cache hit rate > 80% for static data

---

## Related Stories

- **Story 1.10**: í”„ë¡œì íŠ¸ ë©¤ë²„ ë° API í‚¤ ê´€ë¦¬ UI (ê¸°ë°˜)
- **Story 1.11**: ë³´ì•ˆ ê°•í™” (rate limitingê³¼ í•¨ê»˜ ì ìš©)
- **Story 1.13**: êµ­ì œí™” ë° ë°ì´í„° ë¬´ê²°ì„± (ë³‘ë ¬ ê°œì„ )
