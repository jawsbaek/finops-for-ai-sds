# Story 1.14: API í‚¤ ê´€ë¦¬ í†µí•© ë° ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ ì¶”ê°€

**Status:** ðŸ“‹ TODO

**Priority:** ðŸŸ¡ MEDIUM

---

## User Story

**As a** ê°œë°œìž,
**I want** API í‚¤ ê´€ë¦¬ ê¸°ëŠ¥ì— ëŒ€í•œ í¬ê´„ì ì¸ í†µí•© í…ŒìŠ¤íŠ¸ì™€ ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ì—¬,
**So that** ì½”ë“œ ë³€ê²½ ì‹œ íšŒê·€ ë²„ê·¸ë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ê³  ì‹œìŠ¤í…œì˜ ì•ˆì •ì„±ì„ ë³´ìž¥í•  ìˆ˜ ìžˆë‹¤.

---

## Context

**Code Review ë°œê²¬ ì‚¬í•­ (PR #25):**

í˜„ìž¬ API í‚¤ ê²€ì¦ ë¡œì§ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ëŠ” ì¶©ë¶„í•˜ì§€ë§Œ(20ê°œ í…ŒìŠ¤íŠ¸), ë‹¤ìŒ ì˜ì—­ì˜ í…ŒìŠ¤íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤:

### í…ŒìŠ¤íŠ¸ ê°­ ë¶„ì„

#### 1. ì„œë²„ í†µí•© í…ŒìŠ¤íŠ¸ ë¶€ìž¬
**í˜„ìž¬ ìƒí™©:**
- `validateApiKey` í•¨ìˆ˜ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë§Œ ì¡´ìž¬
- End-to-end í†µí•© í…ŒìŠ¤íŠ¸ ì—†ìŒ

**í•„ìš” ì‚¬í•­:**
```typescript
// src/server/api/routers/__tests__/project.test.ts (ì‹ ê·œ)
describe("generateApiKey mutation", () => {
    it("should accept sk-admin- prefixed keys", async () => {
        // Test end-to-end flow with admin keys
    });

    it("should reject keys with invalid formats", async () => {
        // Test that server validation works
    });

    it("should properly encrypt and store API keys", async () => {
        // Test encryption flow
    });
});
```

#### 2. UI ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ ë¶€ìž¬
**í˜„ìž¬ ìƒí™©:**
- `AddApiKeyDialog` ì»´í¬ë„ŒíŠ¸ì— ìƒˆë¡œìš´ `serverError` prop ì¶”ê°€ë¨
- ì—ëŸ¬ í‘œì‹œ ë¡œì§ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì—†ìŒ

**í•„ìš” ì‚¬í•­:**
```typescript
// src/components/dialogs/__tests__/AddApiKeyDialog.test.tsx (ì‹ ê·œ)
describe("AddApiKeyDialog", () => {
    it("should display server errors inline", () => {
        render(<AddApiKeyDialog serverError="Server error" />);
        expect(screen.getByText("Server error")).toBeInTheDocument();
    });

    it("should clear server error when dialog closes", () => {
        // Test error clearing logic
    });

    it("should prioritize server errors over client errors", () => {
        // Test error precedence
    });
});
```

#### 3. íŽ˜ì´ì§€ ë ˆë²¨ ì—ëŸ¬ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ë¶€ìž¬
**í˜„ìž¬ ìƒí™©:**
- `page.tsx`ì— ë³µìž¡í•œ ì—ëŸ¬ ìƒíƒœ ê´€ë¦¬ ë¡œì§ ì¶”ê°€
- ìƒíƒœ ì „í™˜ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì—†ìŒ

**í•„ìš” ì‚¬í•­:**
```typescript
// src/app/(dashboard)/projects/[id]/__tests__/page.test.tsx (ì‹ ê·œ)
describe("Project page - API key error handling", () => {
    it("should clear server error when dialog closes", () => {
        // Test handleAddApiKeyDialogOpenChange
    });

    it("should clear error in onMutate before new submission", () => {
        // Test handleAddApiKey mutation flow
    });

    it("should display errors in dialog instead of toast", () => {
        // Test error display logic
    });
});
```

---

## Acceptance Criteria

### AC1: ì„œë²„ í†µí•© í…ŒìŠ¤íŠ¸ êµ¬í˜„
**Given** API í‚¤ ë“±ë¡ mutationì´ ìžˆì„ ë•Œ,
**When** ë‹¤ì–‘í•œ API í‚¤ í˜•ì‹ìœ¼ë¡œ í…ŒìŠ¤íŠ¸í•˜ë©´,
**Then** ì„œë²„ validationì´ ì˜¬ë°”ë¥´ê²Œ ë™ìž‘í•´ì•¼ í•¨

**êµ¬í˜„ ìš”êµ¬ì‚¬í•­:**
- [ ] `src/server/api/routers/__tests__/project.test.ts` ìƒì„±
- [ ] ë‹¤ì–‘í•œ OpenAI í‚¤ í˜•ì‹ í…ŒìŠ¤íŠ¸ (sk-admin-, sk-proj-, legacy)
- [ ] Invalid format ê±°ë¶€ í…ŒìŠ¤íŠ¸
- [ ] ì•”í˜¸í™” ë° ì €ìž¥ í”Œë¡œìš° í…ŒìŠ¤íŠ¸
- [ ] last4 ì¶”ì¶œ ë° ì €ìž¥ ê²€ì¦
- [ ] KMS í†µí•© í…ŒìŠ¤íŠ¸ (ëª¨í‚¹)
- [ ] ìµœì†Œ 8ê°œ í†µí•© í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### AC2: AddApiKeyDialog ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ êµ¬í˜„
**Given** AddApiKeyDialog ì»´í¬ë„ŒíŠ¸ê°€ ìžˆì„ ë•Œ,
**When** ë‹¤ì–‘í•œ ì—ëŸ¬ ìƒíƒœë¥¼ í…ŒìŠ¤íŠ¸í•˜ë©´,
**Then** UIê°€ ì˜¬ë°”ë¥´ê²Œ ì—ëŸ¬ë¥¼ í‘œì‹œí•´ì•¼ í•¨

**êµ¬í˜„ ìš”êµ¬ì‚¬í•­:**
- [ ] `src/components/dialogs/__tests__/AddApiKeyDialog.test.tsx` ìƒì„±
- [ ] Server error í‘œì‹œ í…ŒìŠ¤íŠ¸
- [ ] Client error í‘œì‹œ í…ŒìŠ¤íŠ¸
- [ ] Error ìš°ì„ ìˆœìœ„ í…ŒìŠ¤íŠ¸ (server > client)
- [ ] Dialog ë‹«íž ë•Œ error ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸
- [ ] ì‚¬ìš©ìž ìž…ë ¥ ì‹œ client error ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸
- [ ] ë¡œë”© ìƒíƒœ í…ŒìŠ¤íŠ¸
- [ ] ìµœì†Œ 6ê°œ ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### AC3: íŽ˜ì´ì§€ ë ˆë²¨ ì—ëŸ¬ ìƒíƒœ ê´€ë¦¬ í…ŒìŠ¤íŠ¸
**Given** í”„ë¡œì íŠ¸ ìƒì„¸ íŽ˜ì´ì§€ê°€ ìžˆì„ ë•Œ,
**When** API í‚¤ ì¶”ê°€ í”Œë¡œìš°ë¥¼ í…ŒìŠ¤íŠ¸í•˜ë©´,
**Then** ì—ëŸ¬ ìƒíƒœê°€ ì˜¬ë°”ë¥´ê²Œ ê´€ë¦¬ë˜ì–´ì•¼ í•¨

**êµ¬í˜„ ìš”êµ¬ì‚¬í•­:**
- [ ] `src/app/(dashboard)/projects/[id]/__tests__/page.test.tsx` ìƒì„±
- [ ] onMutateì—ì„œ error ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸
- [ ] onErrorì—ì„œ error ì„¤ì • í…ŒìŠ¤íŠ¸
- [ ] onSuccessì—ì„œ dialog ë‹«íž˜ í…ŒìŠ¤íŠ¸
- [ ] Dialog open/close ì‹œ error ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸
- [ ] ì—°ì†ëœ mutation í˜¸ì¶œ ì‹œ race condition í…ŒìŠ¤íŠ¸
- [ ] ìµœì†Œ 5ê°œ íŽ˜ì´ì§€ ë ˆë²¨ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### AC4: í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ëª©í‘œ ë‹¬ì„±
**Given** ìƒˆë¡œìš´ í…ŒìŠ¤íŠ¸ê°€ ì¶”ê°€ë˜ì—ˆì„ ë•Œ,
**When** í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ë¥¼ ì¸¡ì •í•˜ë©´,
**Then** ëª©í‘œ ì»¤ë²„ë¦¬ì§€ë¥¼ ë‹¬ì„±í•´ì•¼ í•¨

**ëª©í‘œ:**
- [ ] API í‚¤ ê´€ë ¨ ì½”ë“œ ë¼ì¸ ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ
- [ ] ë¸Œëžœì¹˜ ì»¤ë²„ë¦¬ì§€ 75% ì´ìƒ
- [ ] ëª¨ë“  critical pathì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì¡´ìž¬
- [ ] CI/CD íŒŒì´í”„ë¼ì¸ì—ì„œ ìžë™ ì‹¤í–‰

---

## Technical Specifications

### 1. í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •

#### Testing Libraries
```json
{
  "devDependencies": {
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.1.0",
    "@testing-library/user-event": "^14.5.1",
    "vitest": "^1.0.0",
    "@vitejs/plugin-react": "^4.2.0"
  }
}
```

#### Vitest Configuration
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '__tests__/',
        '*.config.*',
      ],
    },
  },
});
```

### 2. ì„œë²„ í†µí•© í…ŒìŠ¤íŠ¸ êµ¬ì¡°

```typescript
// src/server/api/routers/__tests__/project.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { TRPCError } from '@trpc/server';
import { projectRouter } from '../project';
import { db } from '~/server/db';
import * as apiKeyManager from '~/lib/services/encryption/api-key-manager';

// Mock dependencies
vi.mock('~/server/db');
vi.mock('~/lib/services/encryption/api-key-manager');

describe('projectRouter.generateApiKey', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('API Key Format Validation', () => {
    it('should accept sk-admin- prefixed service account keys', async () => {
      const mockSession = { user: { id: 'user-1' } };
      const mockApiKey = 'sk-admin-' + 'a'.repeat(40);

      vi.spyOn(apiKeyManager, 'validateApiKey').mockReturnValue(true);
      vi.spyOn(apiKeyManager, 'encryptApiKey').mockResolvedValue({
        ciphertext: 'encrypted',
        encryptedDataKey: 'key',
        iv: 'iv',
      });

      const result = await caller.generateApiKey({
        projectId: 'project-1',
        provider: 'openai',
        apiKey: mockApiKey,
      });

      expect(result).toBeDefined();
      expect(apiKeyManager.validateApiKey).toHaveBeenCalledWith(
        mockApiKey,
        'openai'
      );
    });

    it('should accept sk-proj- prefixed project keys', async () => {
      // Test implementation
    });

    it('should reject invalid format keys', async () => {
      const mockApiKey = 'invalid-key-format';

      vi.spyOn(apiKeyManager, 'validateApiKey').mockReturnValue(false);

      await expect(
        caller.generateApiKey({
          projectId: 'project-1',
          provider: 'openai',
          apiKey: mockApiKey,
        })
      ).rejects.toThrow(TRPCError);
    });

    it('should reject keys exceeding 256 characters', async () => {
      const tooLongKey = 'sk-' + 'a'.repeat(257);

      vi.spyOn(apiKeyManager, 'validateApiKey').mockReturnValue(false);

      await expect(
        caller.generateApiKey({
          projectId: 'project-1',
          provider: 'openai',
          apiKey: tooLongKey,
        })
      ).rejects.toThrow('Invalid openai API key format');
    });
  });

  describe('Encryption and Storage', () => {
    it('should encrypt API key before storing', async () => {
      const mockApiKey = 'sk-test-key-12345678901234567890';
      const mockEncrypted = {
        ciphertext: 'encrypted-data',
        encryptedDataKey: 'encrypted-key',
        iv: 'initialization-vector',
      };

      vi.spyOn(apiKeyManager, 'encryptApiKey').mockResolvedValue(mockEncrypted);

      await caller.generateApiKey({
        projectId: 'project-1',
        provider: 'openai',
        apiKey: mockApiKey,
      });

      expect(apiKeyManager.encryptApiKey).toHaveBeenCalledWith(mockApiKey);
      expect(db.apiKey.create).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            encryptedKey: mockEncrypted.ciphertext,
            encryptedDataKey: mockEncrypted.encryptedDataKey,
            iv: mockEncrypted.iv,
          }),
        })
      );
    });

    it('should store only last4 characters for display', async () => {
      const mockApiKey = 'sk-test-key-abcd';

      await caller.generateApiKey({
        projectId: 'project-1',
        provider: 'openai',
        apiKey: mockApiKey,
      });

      expect(db.apiKey.create).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            last4: 'abcd',
          }),
        })
      );
    });
  });

  describe('Authorization', () => {
    it('should reject unauthorized users', async () => {
      // Test access control
    });

    it('should allow project members to add keys', async () => {
      // Test project member access
    });

    it('should allow team admins to add keys', async () => {
      // Test team admin access
    });
  });
});
```

### 3. ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ êµ¬ì¡°

```typescript
// src/components/dialogs/__tests__/AddApiKeyDialog.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { AddApiKeyDialog } from '../AddApiKeyDialog';

describe('AddApiKeyDialog', () => {
  const defaultProps = {
    open: true,
    onOpenChange: vi.fn(),
    onConfirm: vi.fn(),
    isLoading: false,
  };

  describe('Error Display', () => {
    it('should display server error when provided', () => {
      render(
        <AddApiKeyDialog
          {...defaultProps}
          serverError="Invalid API key format"
        />
      );

      expect(screen.getByText('Invalid API key format')).toBeInTheDocument();
    });

    it('should display client error for empty input', async () => {
      const user = userEvent.setup();
      render(<AddApiKeyDialog {...defaultProps} />);

      const confirmButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await user.click(confirmButton);

      expect(screen.getByText('API í‚¤ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”')).toBeInTheDocument();
    });

    it('should prioritize server error over client error', async () => {
      const user = userEvent.setup();
      const { rerender } = render(
        <AddApiKeyDialog {...defaultProps} />
      );

      // Trigger client error
      const confirmButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await user.click(confirmButton);
      expect(screen.getByText('API í‚¤ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”')).toBeInTheDocument();

      // Add server error
      rerender(
        <AddApiKeyDialog
          {...defaultProps}
          serverError="Server validation failed"
        />
      );

      // Server error should be shown instead
      expect(screen.getByText('Server validation failed')).toBeInTheDocument();
      expect(screen.queryByText('API í‚¤ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”')).not.toBeInTheDocument();
    });

    it('should clear client error when user types', async () => {
      const user = userEvent.setup();
      render(<AddApiKeyDialog {...defaultProps} />);

      const confirmButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await user.click(confirmButton);

      expect(screen.getByText('API í‚¤ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”')).toBeInTheDocument();

      const input = screen.getByPlaceholderText('sk-...');
      await user.type(input, 's');

      expect(screen.queryByText('API í‚¤ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”')).not.toBeInTheDocument();
    });
  });

  describe('Form Submission', () => {
    it('should call onConfirm with valid API key', async () => {
      const user = userEvent.setup();
      const onConfirm = vi.fn();

      render(<AddApiKeyDialog {...defaultProps} onConfirm={onConfirm} />);

      const input = screen.getByPlaceholderText('sk-...');
      await user.type(input, 'sk-test-key-12345678901234567890');

      const confirmButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await user.click(confirmButton);

      expect(onConfirm).toHaveBeenCalledWith(
        'openai',
        'sk-test-key-12345678901234567890'
      );
    });

    it('should validate sk- prefix on submit', async () => {
      const user = userEvent.setup();
      const onConfirm = vi.fn();

      render(<AddApiKeyDialog {...defaultProps} onConfirm={onConfirm} />);

      const input = screen.getByPlaceholderText('sk-...');
      await user.type(input, 'invalid-key');

      const confirmButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await user.click(confirmButton);

      expect(screen.getByText(/sk-ë¡œ ì‹œìž‘í•´ì•¼ í•©ë‹ˆë‹¤/)).toBeInTheDocument();
      expect(onConfirm).not.toHaveBeenCalled();
    });
  });

  describe('Dialog State Management', () => {
    it('should reset form when dialog closes', async () => {
      const user = userEvent.setup();
      const { rerender } = render(<AddApiKeyDialog {...defaultProps} />);

      const input = screen.getByPlaceholderText('sk-...');
      await user.type(input, 'sk-test-key');

      // Close dialog
      rerender(<AddApiKeyDialog {...defaultProps} open={false} />);

      // Reopen dialog
      rerender(<AddApiKeyDialog {...defaultProps} open={true} />);

      expect(input).toHaveValue('');
    });
  });

  describe('Loading State', () => {
    it('should disable inputs when loading', () => {
      render(<AddApiKeyDialog {...defaultProps} isLoading={true} />);

      const input = screen.getByPlaceholderText('sk-...');
      const confirmButton = screen.getByText('ì¶”ê°€ ì¤‘...');

      expect(input).toBeDisabled();
      expect(confirmButton).toBeDisabled();
    });
  });
});
```

### 4. íŽ˜ì´ì§€ ë ˆë²¨ í…ŒìŠ¤íŠ¸ êµ¬ì¡°

```typescript
// src/app/(dashboard)/projects/[id]/__tests__/page.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ProjectDetailPage from '../page';
import { api } from '~/trpc/react';

// Mock tRPC
vi.mock('~/trpc/react', () => ({
  api: {
    useUtils: vi.fn(),
    project: {
      getById: {
        useQuery: vi.fn(),
      },
      generateApiKey: {
        useMutation: vi.fn(),
      },
    },
  },
}));

describe('ProjectDetailPage - API Key Error Handling', () => {
  describe('Error State Management', () => {
    it('should clear error in onMutate before new submission', async () => {
      let mutationCallbacks: any = {};

      vi.mocked(api.project.generateApiKey.useMutation).mockImplementation((config) => {
        mutationCallbacks = config;
        return {
          mutate: vi.fn((vars) => {
            config?.onMutate?.();
          }),
          isPending: false,
        } as any;
      });

      render(<ProjectDetailPage />);

      // Simulate first error
      mutationCallbacks.onError?.({ message: 'First error' });

      expect(screen.getByText('First error')).toBeInTheDocument();

      // Simulate second mutation
      const mutate = vi.fn();
      mutationCallbacks.onMutate?.();

      // Error should be cleared
      await waitFor(() => {
        expect(screen.queryByText('First error')).not.toBeInTheDocument();
      });
    });

    it('should display server error in dialog on mutation error', async () => {
      let mutationCallbacks: any = {};

      vi.mocked(api.project.generateApiKey.useMutation).mockImplementation((config) => {
        mutationCallbacks = config;
        return {
          mutate: vi.fn(),
          isPending: false,
        } as any;
      });

      render(<ProjectDetailPage />);

      // Open dialog
      const addButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await userEvent.click(addButton);

      // Trigger error
      mutationCallbacks.onError?.({ message: 'Invalid API key format' });

      // Error should be visible in dialog
      expect(screen.getByText('Invalid API key format')).toBeInTheDocument();
    });

    it('should clear error when dialog closes', async () => {
      render(<ProjectDetailPage />);

      // Open dialog and trigger error
      const addButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await userEvent.click(addButton);

      // Simulate error (would come from mutation)
      // ... trigger error state ...

      // Close dialog
      const cancelButton = screen.getByText('ì·¨ì†Œ');
      await userEvent.click(cancelButton);

      // Reopen dialog
      await userEvent.click(addButton);

      // Error should be cleared
      // ... assert no error message ...
    });
  });

  describe('Race Condition Prevention', () => {
    it('should handle rapid consecutive submissions', async () => {
      const mutateFn = vi.fn();
      let onMutate: any;

      vi.mocked(api.project.generateApiKey.useMutation).mockImplementation((config) => {
        onMutate = config?.onMutate;
        return {
          mutate: mutateFn,
          isPending: false,
        } as any;
      });

      render(<ProjectDetailPage />);

      // Simulate rapid clicks
      const addButton = screen.getByText('API í‚¤ ì¶”ê°€');
      await userEvent.click(addButton);

      // First submission
      onMutate?.();
      mutateFn();

      // Second submission before first completes
      onMutate?.();
      mutateFn();

      // Should clear error on each onMutate
      expect(mutateFn).toHaveBeenCalledTimes(2);
    });
  });
});
```

---

## Tasks

### Setup (1 story point)
- [ ] Review and update test dependencies
- [ ] Configure vitest for React component testing
- [ ] Setup test utilities and helpers
- [ ] Create test setup file with global mocks

### Server Integration Tests (3 story points)
- [ ] Create `src/server/api/routers/__tests__/project.test.ts`
- [ ] Implement API key format validation tests (4 tests)
- [ ] Implement encryption and storage tests (2 tests)
- [ ] Implement authorization tests (3 tests)
- [ ] Add edge case tests (max length, special chars)

### Component Tests (3 story points)
- [ ] Create `src/components/dialogs/__tests__/AddApiKeyDialog.test.tsx`
- [ ] Implement error display tests (3 tests)
- [ ] Implement form submission tests (2 tests)
- [ ] Implement dialog state management tests (1 test)
- [ ] Implement loading state tests (1 test)

### Page Level Tests (2 story points)
- [ ] Create `src/app/(dashboard)/projects/[id]/__tests__/page.test.tsx`
- [ ] Implement error state management tests (3 tests)
- [ ] Implement race condition prevention tests (2 tests)
- [ ] Add integration scenarios

### Documentation & CI (1 story point)
- [ ] Update README with testing guidelines
- [ ] Add test coverage reporting to CI
- [ ] Document test patterns and best practices
- [ ] Create testing checklist for future PRs

---

## Dependencies

**Blocked by:**
- None (can start immediately)

**Blocks:**
- Future API key related features (will benefit from test foundation)

**Related:**
- Story 1.11: ë³´ì•ˆ ê°•í™” (completed - provides test subjects)
- PR #25: API key format support (completed - provides test subjects)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Minimum 19 new test cases added (8 integration + 6 component + 5 page)
- [ ] All tests passing in CI/CD
- [ ] Test coverage for API key code â‰¥ 80%
- [ ] No regression in existing tests
- [ ] Code review completed
- [ ] Documentation updated
- [ ] CI/CD pipeline includes new tests

---

## Testing Strategy

### Test Pyramid
```
      /\
     /  \    E2E (existing user journey tests)
    /----\
   /      \  Integration (this story - 8 tests)
  /--------\
 /          \ Unit (existing + component - 26 tests)
/____________\
```

### Coverage Goals
- **Unit Tests**: 96 â†’ 122 tests (26 new)
- **Integration Tests**: 0 â†’ 8 tests (8 new)
- **Component Tests**: 0 â†’ 6 tests (6 new)
- **Total New Tests**: 19 minimum

### Risk Mitigation
- Focus on critical paths first (validation, encryption)
- Mock external dependencies (KMS, database)
- Test error scenarios thoroughly
- Validate race condition handling

---

## Notes

**From Code Review:**
> "Test coverage estimate: ~70% (excellent for unit tests, but integration tests would boost this)"

**Estimated Effort:** 10 story points (Medium complexity)

**Testing Philosophy:**
- Integration tests validate the happy path and critical error scenarios
- Component tests ensure UI correctly displays all states
- Page tests validate complex state management logic
- All tests should be maintainable and readable

**Follow-up Opportunities:**
- E2E tests for complete user flows (separate story)
- Performance tests for encryption operations
- Security tests for injection attacks
